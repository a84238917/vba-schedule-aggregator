## このドキュメントの目的 (存在意義)

この「期待する動作（プログラムの挙動）書」ドキュメントは、**「VBA Schedule Aggregator (工程表データ集約マクロ)」が実行された際に、ユーザーが体験するであろう一連の処理フロー、主要なロジックの分岐、エラー発生時の具体的な対応、そして最終的に得られる結果について、ステップバイステップで詳細に記述したもの**です。
これは、マクロの機能仕様を補完し、システムが実際にどのように振る舞うべきかの具体的なイメージを開発者（AIを含む）に提供します。
このドキュメントは、マクロのユーザーエクスペリエンス（使い勝手）を考慮した設計を促し、実装された機能がユーザーの期待と一致することを保証するための重要なガイドラインとなります。また、テストケースを作成する際の基礎情報としても活用されます。
この文書を通じて、マクロの具体的な動作シーケンスと、様々な状況下での応答に関する共通理解を確立します。

---

**対象システム:** VBA Schedule Aggregator (工程表データ集約マクロ)
**バージョン:** 1.1 (再構築版)

### 1. マクロ実行開始と初期化

1.  **トリガー:** ユーザーがExcelリボン上のボタン、クイックアクセスツールバーのアイコン、または割り当てられたショートカットキー等を用いてマクロの実行を開始します。
2.  **初期応答:** マクロの実行が開始されると、まず以下の内部的な初期化処理がバックグラウンドで行われます。
    a.  **グローバル設定領域の準備:** マクロ全体で使用する設定情報（Configシートから読み込むデータ）を格納するための内部的なデータ構造（例: `g_Config`という名前のユーザー定義型変数）をクリアし、マクロの実行開始時刻や、このマクロファイル自身のフルパスといった基本情報を記録します。
    b.  **Excel環境の一時最適化:** 処理速度の向上とユーザーへの不要な表示の抑制のため、以下のExcelアプリケーション設定が自動的に変更されます。
        i.  画面描画の停止 (`Application.ScreenUpdating = False`)。
        ii. Excelの自動計算の一時停止 (`Application.Calculation = xlCalculationManual`)。
        iii. Excelからの標準的な警告ダイアログの表示抑制 (`Application.DisplayAlerts = False`)。
        iv. 不要なイベント処理の一時停止 (`Application.EnableEvents = False`)。
    c.  マクロ処理の内部的な開始時刻が記録されます。
3.  **デバッグログの開始 (デバッグモード時):** 「Config」シートの`O3`「デバッグモードフラグ」が`TRUE`に設定されている場合、イミディエイトウィンドウに「マクロ実行開始。初期化処理完了。」といった趣旨のログが出力されます。

### 2. Configシートからの設定情報の読み込みと検証

1.  **`Config`シートの特定:** マクロは、自身のファイル内に`CONFIG_SHEET_DEFAULT_NAME`定数（通常は "Config (2)"）で指定された名前のワークシートが存在するか確認します。
    *   **失敗時:** 該当するシートが見つからない場合、「設定シート 'Config (2)' が見つかりません。マクロを続行できません。」といった内容のエラーメッセージダイアログをユーザーに表示します。同時に、エラーログシート（もし準備できていれば）に「致命的エラー：Configシート不在」といった内容を記録し、マクロは「7. 終了処理」シーケンスへ移行し、安全に終了します。
2.  **設定値の読み取り:** 「Configシート定義」ドキュメントに詳述されている各セル範囲から、マクロの動作に必要な全ての設定値（ファイルパス、シート名、オフセット、フィルター条件など）を読み取り、内部のグローバル設定構造体（例: `g_Config`）に格納します。
3.  **設定値の検証:** 読み取った各設定値に対して、以下の検証を順次行います。
    *   **必須項目の存在確認:** 「Configシート定義」で必須とされている項目が空欄または未入力の場合、エラーログに該当セルと「必須項目未入力」の旨を記録し、内部的なエラー発生フラグを立てます。
    *   **データ型と書式の検証:** 数値であるべき項目が文字列であったり、セルアドレスの書式が不正であったり、オフセット値が「行,列」形式でなかったりする場合、エラーログに該当セルとエラー内容（例:「O87のヘッダー行数は数値である必要があります」）を記録し、エラー発生フラグを立てます。可能であれば、プログラムが停止しないように安全なデフォルト値（例: 数値なら0、文字列なら空文字）を内部的に使用し、その旨もログに記録します。
    *   **有効範囲の検証:** 特定の数値範囲が期待される設定項目（例: `O690`ヘッダー行数 1～10）がその範囲外の値である場合、エラーログに記録し、エラー発生フラグを立て、可能であれば範囲内のデフォルト値を使用します。
    *   **特定の選択肢の検証:** 特定の文字列（例: `O242`の`AND`/`OR`、`O1124`の`リセット`/`引継ぎ`）が期待されるものと異なる場合、エラーログに記録し、プログラムが安全に動作するデフォルトの選択肢（例: `OR`、`リセット`）を内部的に使用します。
4.  **読み込み結果の最終判定:** 全ての設定項目を読み込み・検証した後、内部的なエラー発生フラグが立っている（つまり、何らかの設定不備があった）場合、ユーザーに「Configシートの設定にエラーがあります。詳細はエラーログシートを確認してください。」という内容のメッセージダイアログを表示し、マクロは「7. 終了処理」シーケンスへ移行し、安全に終了します。

### 3. 処理用ワークシートの準備

1.  **主要シートの準備:**
    a.  「Config」シートの`O43`「抽出結果出力シート名」、`O44`「検索条件ログシート名」、`O45`「エラーログシート名」で指定された名前のワークシートが、マクロ実行ファイル内に存在するか確認します。
    b.  いずれかのシートが存在しない場合、マクロは自動的にその名前で新しいワークシートをブックの末尾に追加します。
        i.  **出力シートの新規作成時:** 「Config」シートの`O811`「出力シートヘッダー行数」と`O812`-`O821`「出力シートヘッダー内容」の定義に基づき、1行目から指定された行数分のヘッダーを作成します。ヘッダー内容はタブ区切りで各列に展開されます。
        ii. **ログシートの新規作成時:** 1行目に固定の簡易ヘッダー（例: エラーログなら「発生日時」「モジュール」「エラー内容」など）を作成します。
    c.  **失敗時:** 上記の必須シートの準備（存在確認または新規作成）に何らかの理由で失敗した場合（例: 同名シートが保護されていて操作できない、など稀なケース）、エラーログに詳細を記録し、ユーザーに「ワークシートの準備に失敗しました。」といったメッセージを表示後、マクロは「7. 終了処理」へ移行します。
2.  **オプションシートの準備:** 「Config」シートで名前が指定されていれば、「Work」シート、「メニュー」シート、「リスト」シートについても同様に存在確認を行い、なければ空のシートとして作成します（これらのヘッダーは本仕様では定義しません）。こちらの準備失敗はマクロ全体の動作を停止させません（警告ログのみ）。
3.  **グローバルログ変数の設定:** 準備（または確認）できたエラーログシートのオブジェクト参照を、グローバル変数（例: `g_wsErrorLog`）に格納し、エラーログの次の書き込み行番号（例: `g_NextErrorLogRow`、通常はヘッダーの次の行）を初期設定します。
4.  **出力シートの初期化:**
    a.  「Config」シートの`O43`で指定された出力シートのオブジェクト参照を取得します。
    b.  もし出力シートにオートフィルタが設定されていれば、それを解除します (`ShowAllData`)。
    c.  「Config」シートの`O1124`「出力データオプション」の値を確認します。
        i.  値が "リセット" (大文字小文字区別なし) の場合: 出力シートの既存のデータ（ヘッダー行は除く）を全てクリアします。次のデータ書き込み開始行は、ヘッダー行の直下の行となります。
        ii. 値が "引継ぎ" (大文字小文字区別なし) の場合: 出力シートのA列を基準に、最終データが入力されている行の次の行を、新たなデータ書き込み開始行として特定します。もしシートが空またはヘッダー行のみの場合は、ヘッダー行の直下の行が書き込み開始行となります。
        iii.上記以外の場合: "リセット" と同様の動作をします。

### 4. 処理対象ファイルの特定とリスト化

1.  **`Config`シートのパスリスト優先処理:**
    a.  「Config」シートの`P557`-`P756`「処理対象ファイル/フォルダパスリスト」を上から順に確認します。
    b.  各行について、パスが入力されていれば、それがファイルかフォルダかを判定します。
        i.  **ファイルの場合:** そのファイルが存在し、かつExcelファイル（拡張子が `.xlsx`, `.xls`, `.xlsm` のいずれか）であれば、そのフルパスを内部の処理対象リストに追加します。Excelファイルでない、または存在しない場合は、エラーログにその旨を記録し、スキップします。
        ii. **フォルダの場合:** そのフォルダが存在すれば、そのフォルダ直下にある全てのファイルを確認し、Excelファイル（上記拡張子）であれば、そのフルパスを内部の処理対象リストに追加します。サブフォルダ内のファイルは探索しません。フォルダが存在しない場合はエラーログに記録し、スキップします。
    c.  上記処理の結果、1件以上の有効なファイルパスが処理対象リストに追加された場合、次の「5. 検索条件ログの出力」へ進みます。
2.  **ファイル選択ダイアログの表示 (上記リストが空の場合):**
    a.  上記1で処理対象リストが空（有効なパスが一つもなかった）の場合、Excelのファイル選択ダイアログを表示します。
    b.  ダイアログのタイトルは「処理対象の工程表Excelファイルを選択してください（複数選択可）」とします。
    c.  ファイルの種類フィルターは「Excelファイル (*.xlsx; *.xls; *.xlsm)」のみに設定します。
    d.  ダイアログの初期表示フォルダは、「Config」シートの`O12`「デフォルトフォルダパス」で指定されたパスとします。そのパスが無効または空の場合は、マクロ実行ファイルが保存されているフォルダを初期表示とします。
    e.  ユーザーが1つ以上のファイルを選択し「開く」をクリックした場合、選択された全てのファイルのフルパスを内部の処理対象リストに追加します。
    f.  ユーザーがダイアログで「キャンセル」をクリックした場合、「処理がキャンセルされました。」といったメッセージをユーザーに表示し、マクロは「7. 終了処理」へ移行します。
3.  **最終処理対象リストの確認:**
    a.  上記1または2の結果、内部の処理対象リストに1件もファイルパスが含まれていない場合、「処理対象ファイルが見つかりませんでした。」というメッセージをユーザーに表示し、マクロは「7. 終了処理」へ移行します。
    b.  処理対象リストには、各ファイルパスに対応する「適用工程パターン識別子」（「Config」シート`Q557`-`Q756`から取得）もペアで保持します。`Q列`が空の場合は、デフォルトのパターン識別子（例: "1"）を使用します。

### 5. 検索条件ログの出力

1.  「Config」シートの`O44`で指定された検索条件ログシートに、以下の情報を追記します。
    *   現在のマクロ実行日時。
    *   「--- マクロ実行開始 ---」のような区切り線。
    *   マクロ実行ファイル自身のフルパス。
    *   「Config」シートから読み込んだ主要なフィルター条件の設定値（作業員フィルターの論理とリスト、管内1/2フィルターリスト、分類1/2/3フィルター条件、工事種類、工番、作業種類、担当の名前、人数、作業箇所の種類、作業箇所フィルターリストなど、実際に値が設定されているもの）。
    *   処理対象として特定されたファイルの総数。
    *   `O122`「工程パターンデータ取得方法」フラグの値。

### 6. メイン処理ループ (ファイル単位)

4で特定された処理対象ファイルのリスト（ファイルパスと対応する工程パターン識別子のペア）を、リストの先頭から順に一つずつ処理します。各ファイルに対して以下のステップを実行します。

1.  **進捗表示 (ステータスバー):** Excelのステータスバーに「処理中: (ファイル名) (X/Y件目)」のように、現在の処理状況を表示します。
2.  **ファイルオープン:**
    a.  対象の工程表ファイルを**読み取り専用モード**で開きます。リンクの更新は行いません。
    b.  **失敗時:** ファイルオープンに失敗した場合（例: ファイルが見つからない、パスワードで保護されていて開けない、ファイルが破損している）、エラーログにファイル名と具体的なエラー内容を記録し、このファイルの処理を中断して、リスト内の次のファイルの処理へ進みます (`GoTo NextFileInLoop_Label` など)。
3.  **工程パターン関連情報の準備:**
    a.  現在のファイルに対応する「適用工程パターン識別子」を「Config」シートの`O126`セルにVBAで書き込みます。
    b.  「Config」シートの`O122`「工程パターンデータ取得方法」フラグの値に基づいて、以下のいずれかの方法で、現在の工程パターンに対応する「管内1/2情報」「分類1/2/3情報」「各工程表シート名ごとの工程列数リスト」を取得し、VBAの内部変数（配列やコレクションなど）に格納します。
        i.  **`O122`が`TRUE` (Excel数式再計算待ち):**
            1.  `Application.Calculate` を実行し、ブック全体の再計算を強制します。
            2.  **適切な待機処理:** 数秒固定で待つ (`Application.Wait`)か、より堅牢な方法として、「Config」シートの`J129`セル（または他のキーとなる数式セル）の値がエラー値（`#N/A`, `#CALC!`など）でなくなるまで、`DoEvents` を挟みながらループで監視します（無限ループを避けるためタイムアウト処理も考慮）。
            3.  再計算が完了したと判断された後、「Config」シートの`J129:N(128+O114の値)`範囲から「管内1」「管内2」「分類1」「分類2」「分類3」のデータを、「Config」シートの`O129:X(128+O114の値)`範囲から、`O128:X128`のヘッダー（工程表シート名）と`I129`以降の工程キーに対応する「工程列数」のデータを読み取り、それぞれ内部変数に格納します。
        ii. **`O122`が`FALSE` (VBAによる`Work`シート直接参照):**
            1.  VBAのロジックを使用して、「Work」という名前のワークシートを開き（またはアクティブにし）、`O126`に設定された（または`Q列`から直接取得した）パターン識別子、「Config」シート`I列`の工程キーリスト、「Config」シート`O128:X128`のシート名ヘッダーを検索キーとして使用します。
            2.  `Work`シート内を検索し、合致するレコードから「管内1」「管内2」「分類1」「分類2」「分類3」のデータ、および各シート名に対応する「工程列数」のデータを取得し、それぞれ内部変数に格納します。
    c.  **失敗時:** 上記いずれかの方法で必要なパターン情報が取得できなかった場合（例: `Work`シートに該当データがない、Configシートの数式がエラーを返したまま等）、エラーログにファイル名と状況を記録し、このファイルの処理を中断して次のファイルの処理へ進むか、あるいは処理を継続できる最小限のデフォルトパターン情報（例: 全ての管内・分類を空白、全ての工程列数を1とするなど）を内部的に使用し、その旨をログに記録します。
4.  **シート処理ループ:** 「Config」シートの`O66`-`O75`「工程表内 検索対象シート名リスト」に記載された各シート名を順に処理します。
    a.  現在開いている工程表ファイル（`wbKoutei`）内に、対象のシート名が存在するか確認します。
    b.  **失敗時:** シートが存在しない場合、エラーログにファイル名と存在しなかったシート名を記録し、このシートの処理をスキップして、リスト内の次のシート名の処理へ進みます (`GoTo NextSheetInLoop_Label` など)。
    c.  **年月取得:**
        i.  「Config」シートの`O101`「「年」のセルアドレス」および`O102`「「月」のセルアドレス」で指定されたセルから、現在のシートの「年」と「月」の情報を取得します。
        ii. **検証とエラー処理:** 取得した値が空、数値でない、または暦として明らかに不正な範囲（例: 月が0や13以上）である場合、エラーログに記録します。その際、もし`lastValidYear`と`lastValidMonth`（このマクロ実行中に、前のファイルまたはシートで正常に取得できた最後の年月）に有効な値が保持されていれば、それを現在のシートの年月として流用し、ログにその旨を記録します。流用できる前回値がない場合（例: 最初のファイル・シートでの取得失敗）、このシートの処理を中断し、エラーログに記録後、リスト内の次のシート名の処理へ進みます。
        iii.正常に年月が取得または流用できた場合、その値を`lastValidYear`, `lastValidMonth`として更新します。
    d.  現在のシートにおける「前回有効だった日付 (`lastValidDateInSheet`)」をリセット（例: 0やEmptyに）します。
    e.  **日処理ループ:** 1日から「Config」シートの`O90`「1シート内の最大日数」で指定された日数まで、日カウンタ（例: `dayLoopIdx`）をインクリメントしながらループします。
        i.  **日付の確定:**
            1.  現在の`dayLoopIdx`と「Config」`O87`「工程表ヘッダー行数」および`O89`「1日のデータが占める行数」から、その日のデータブロックの開始行番号（例: `dataBlockStartRow`）を計算します。
            2.  `dataBlockStartRow`と「Config」`O104`「「日」の値の行オフセット」から、「日」の数値が記載されている実際の行番号（例: `dayCellActualRow`）を計算します。
            3.  「Config」`O103`「「日」の値がある列文字」から、実際の列番号（例: `dayCellActualCol`）を特定します。
            4.  `wsKoutei.Cells(dayCellActualRow, dayCellActualCol).Value`から「日」の数値（例: `dayValueFromCell`）を取得します。
            5.  **検証とエラー処理:**
                *   `dayValueFromCell`がEmptyの場合: `lastValidDateInSheet`に有効な日付があればそれを`currentDateInLoop`として流用し、ログに記録します。なければ、エラーログに記録し、この日の処理をスキップします (`GoTo NextDayInLoop_Label`など)。
                *   `dayValueFromCell`が数値でない場合: エラーログに記録し、この日の処理をスキップします。
                *   `dayValueFromCell`が数値だが1～31の範囲外の場合: `lastValidDateInSheet`があれば流用（ログ記録）、なければスキップ（ログ記録）。
                *   上記をクリアした場合、`DateSerial(currentYear, currentMonth, CLng(dayValueFromCell))` を試行して日付オブジェクト `currentDateInLoop` を生成します。もし`DateSerial`がエラー（例: 2月30日など）を返した場合、`lastValidDateInSheet`があれば流用（ログ記録）、なければスキップ（ログ記録）。
            6.  日付が正常に確定した場合、その値を`lastValidDateInSheet`として更新します。
        ii. **工程処理ループ:** 工程カウンタ（例: `processLoopIdx`）を0から「Config」`O114`「1日の工程数」-1までインクリメントしながらループします。
            1.  **基準列の計算:** 現在の工程の基準となる列番号（例: `currentProcessBaseCol`）を計算します。最初の工程 (`processLoopIdx = 0`) の基準列は「Config」`O88`「工程表ヘッダー列数」+1 となります。2番目以降の工程では、直前の工程が使用した列数（`previousProcessColsUsed`）を現在の基準列に加算します。
            2.  **工程固有情報の取得:** 現在の`processLoopIdx`に対応する「管内1」「管内2」「分類1」「分類2」「分類3」の情報を、手順6-3-bで内部変数に格納したパターンデータから取得します。
            3.  **当シート・当工程の列数取得:** 現在処理中の工程表シート名（`currentSheetName`）と現在の`processLoopIdx`に対応する「工程列数」（例: `currentProcessActualNumCols`）を、手順6-3-bで内部変数に格納したパターンデータ（シート名ヘッダー`C-8`と工程列数定義`C-9`のマッチング結果）から取得します。
            4.  **データ項目の一括抽出:** 一時的な1次元配列（例: `extractedData`、サイズは最大抽出項目数+α）を用意し、以下の順序でデータを格納します。
                A.  `extractedData(1)` = `currentDateInLoop` (確定した日付)
                B.  `extractedData(2)` = 上記6-6-ii-2で取得した「管内1」
                C.  `extractedData(3)` = 上記6-6-ii-2で取得した「管内2」
                D.  「Config」`F-1`「オフセット項目名リスト」と`F-2`「オフセット値リスト」を順に参照し、各項目名（例: "工番", "変電所", "作業名1", "作業名2", "担当の名前", "工事種類", "人数", "分類1抽出元", "旧その他", "終了時間"）に対応するオフセット値を使い、`wsKoutei.Cells(dataBlockStartRow + オフセット行, currentProcessBaseCol + オフセット列).Value` からデータを取得し、`extractedData`配列の所定のインデックス（例: 工番なら`extractedData(4)`）に格納します。
                    *   `Config`でオフセット指定が元々空欄だった項目（`Is...OriginallyEmpty`フラグが`True`）については、データ取得を試みず、`extractedData`の対応要素を空文字列 `""` とします。
                E.  **作業員名の抽出:** 「Config」`F-1`/`F-2`の "作業員" 項目のオフセットを作業員1の基準とします。作業員カウンタを1から最大10までループさせ、かつカウンタが上記6-6-ii-3で取得した `currentProcessActualNumCols` 以下である間、列オフセットを（作業員カウンタ - 1）だけ加算して作業員名を取得し、`extractedData`配列の作業員名格納領域（例: `extractedData(11)`から`extractedData(20)`）に順次格納します。該当する作業員がいない場合は空文字列とします。抽出できた作業員の実数をカウントしておきます（例: `actualExtractedWorkerCount`）。
                F.  （フィルター専用項目）「工事種類」と「担当の名前」も、それぞれのオフセット定義に基づき抽出し、`extractedData`配列の予備領域（例: `extractedData(20)`, `extractedData(21)`）に格納しておきます（これらは一覧シートへの直接出力対象ではないが、フィルター判定で使用）。
            5.  **空白行判定:** `extractedData`配列内の主要データ項目（日付、管内1/2を除く。例えば、工番、変電所、作業名1、作業名2、分類1、人数）と、抽出された全作業員名（上記6-6-ii-4-E）が全て空文字列またはEmptyであるかを確認します。もし全て空白であれば、この工程データは有効な情報を含まないとみなし、この工程の処理をスキップして次の工程へ進みます (`GoTo NextProcessInLoop_Label` など)。
            6.  **フィルター判定:** 上記6-6-ii-5の空白行判定を通過した `extractedData` に対し、「Config」シートDセクション「フィルター条件」で定義された全ての有効なフィルター（条件が設定されているもの）を適用します。
                *   各フィルター項目について、「Configシート定義」で指定された抽出元データ（`extractedData`配列のどのインデックスか、または`Config`のCセクションのどの列か）、比較方法（完全一致/部分一致、大文字小文字区別有無）、検索論理（AND/OR）に従って、抽出データが条件に合致するかを判定します。
                *   全てのフィルター条件（AND条件で結ばれるもの）を満たした場合のみ、`isFilterMatched`フラグを`True`とします。一つでも条件を満たさなければ`False`とします。
            7.  **データ書き出し:** `isFilterMatched`フラグが`True`の場合のみ、以下の処理を行います。
                A.  マクロ全体の総抽出件数（例: `totalExtractedCount`）を1つインクリメントします。
                B.  出力シート（`wsOutput`）の`outputNextRow`で示される行に、`extractedData`配列の内容を、「一覧」シートのヘッダー列順序に従って書き出します。日付は "yyyy/mm/dd(aaa)" 形式の文字列に変換します。作業員名は最大10名分書き出します。
                C.  `outputNextRow`を1つインクリメントします。
`NextProcessInLoop_Label:` (工程ループの最後)
        iii. `Next processLoopIdx` (次の工程へ)
`NextDayInLoop_Label:` (日ループの最後)
    f.  `Next dayLoopIdx` (次の日へ)
`NextSheetInLoop_Label:` (シートループの最後)
5.  `Next sheetNameItem` (次のシートへ)
6.  現在の工程表ファイル（`wbKoutei`）を**保存せずに**閉じます。
`NextFileInLoop_Label:` (ファイルループの最後)
7.  `Next filePath` (次のファイルへ)

### 7. 終了処理

1.  **Excelアプリケーション設定の復元:** マクロ実行開始時（手順1-2-d）に変更した`Application.ScreenUpdating`, `Application.Calculation`, `Application.DisplayAlerts`, `Application.EnableEvents`の設定を、それぞれマクロ実行前の状態（通常は`True`, `xlCalculationAutomatic`, `True`, `True`）に戻します。
2.  **ステータスバーのクリア:** `Application.StatusBar = False` を実行し、ステータスバーの表示を元に戻します。
3.  **指定シートの非表示:** 「Config」シートの`O1127`-`O1146`「マクロ実行後非表示シートリスト」に記載された名前のシートを、「Config」`O1126`「非表示方式」で指定された方法（`xlSheetHidden` または `xlSheetVeryHidden`）で非表示にします。ただし、「Config」`O43`「抽出結果出力シート名」で指定されたシートは、このリストに含まれていても非表示にしません。存在しないシート名が指定されている場合は、エラーログに記録し、無視します。
4.  **出力シートのアクティブ化:** 「Config」シートの`O43`「抽出結果出力シート名」で指定されたワークシートをアクティブにして表示します。
5.  **完了メッセージの表示:** ユーザーに対し、「処理が完了しました。抽出件数: [総抽出件数]件、処理時間: [総処理時間]秒」という内容のメッセージボックスを表示します。総処理時間は、手順1-2-eで記録した開始時刻と現在の時刻の差から計算します。
6.  **オブジェクト変数の解放:** プログラム中で `Set` を用いて代入した全てのオブジェクト変数（Workbook, Worksheet, Collection, FileSystemObjectなど）を、`Set 変数名 = Nothing` によって明示的に解放します。

---